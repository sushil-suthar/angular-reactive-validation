/**
 * @dynamic
 */
export class ValidatorDeclaration {
    /**
     * Wraps your own validator functions for use with the angular-reactive-validation library.
     *
     * @param validatorFn A function you want to wrap which can validate a control.
     * @param resultKey The error key used for indicating an error result as returned from the ValidatorFn.
     */
    static wrapNoArgumentValidator(validatorFn, resultKey) {
        return (message) => (control) => ValidatorDeclaration.validateAndSetMessageIfInvalid(control, () => validatorFn, resultKey, message);
    }
    /**
     * Wraps your own validator functions for use with the angular-reactive-validation library.
     *
     * @param validatorFactoryFn A function which accepts a single argument and returns a ValidatorFn.
     * @param resultKey The error key used for indicating an error result as returned from the ValidatorFn.
     */
    static wrapSingleArgumentValidator(validatorFactoryFn, resultKey) {
        return (arg1, message) => (control) => {
            const unwrappedArg1 = ValidatorDeclaration.unwrapArgument(arg1);
            return ValidatorDeclaration.validateAndSetMessageIfInvalid(control, validatorFactoryFn, resultKey, message, unwrappedArg1);
        };
    }
    /**
     * Wraps your own validator functions for use with the angular-reactive-validation library.
     *
     * @param validatorFactoryFn A function which accepts two arguments and returns a ValidatorFn.
     * @param resultKey The error key used for indicating an error result as returned from the ValidatorFn.
     */
    static wrapTwoArgumentValidator(validatorFactoryFn, resultKey) {
        return (arg1, arg2, message) => (control) => {
            const unwrappedArg1 = ValidatorDeclaration.unwrapArgument(arg1);
            const unwrappedArg2 = ValidatorDeclaration.unwrapArgument(arg2);
            return ValidatorDeclaration.validateAndSetMessageIfInvalid(control, validatorFactoryFn, resultKey, message, unwrappedArg1, unwrappedArg2);
        };
    }
    static unwrapArgument(arg) {
        if (arg instanceof Function) {
            arg = arg();
        }
        return arg;
    }
    static validateAndSetMessageIfInvalid(control, 
    // eslint-disable-next-line @typescript-eslint/no-shadow
    validatorFactoryFn, resultKey, 
    // eslint-disable-next-line @typescript-eslint/no-shadow
    message, ...args) {
        const validationResult = ValidatorDeclaration.validate(control, validatorFactoryFn, ...args);
        ValidatorDeclaration.setMessageIfInvalid(control, resultKey, validationResult, message, ...args);
        return validationResult;
    }
    // eslint-disable-next-line @typescript-eslint/no-shadow
    static validate(control, validatorFactoryFn, ...args) {
        const wrappedValidatorFn = validatorFactoryFn(...args);
        return wrappedValidatorFn(control);
    }
    static setMessageIfInvalid(control, resultKey, 
    // eslint-disable-next-line @typescript-eslint/no-shadow
    validationResult, message, ...args) {
        if (message) {
            if (validationResult && validationResult[resultKey]) {
                if (typeof message === 'function') {
                    message = message(...args);
                }
                // Not all validators set an object. Often they'll simply set a property to true.
                // Here, we replace any non-object (or array) to be an object on which we can set a message.
                if (!ValidatorDeclaration.isObject(validationResult[resultKey])) {
                    validationResult[resultKey] = {};
                }
                validationResult[resultKey]['message'] = message;
            }
        }
    }
    static isObject(arg) {
        return arg !== null && typeof arg === 'object' && !Array.isArray(arg);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9yLWRlY2xhcmF0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci1yZWFjdGl2ZS12YWxpZGF0aW9uL3NyYy9saWIvdmFsaWRhdG9yLWRlY2xhcmF0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBOztHQUVHO0FBQ0gsTUFBTSxPQUFPLG9CQUFvQjtJQUMvQjs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxXQUF3QixFQUFFLFNBQWlCO1FBRXRFLE9BQU8sQ0FBQyxPQUFpQyxFQUFlLEVBQUUsQ0FBQyxDQUFDLE9BQXdCLEVBQTJCLEVBQUUsQ0FDakgsb0JBQW9CLENBQUMsOEJBQThCLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDeEcsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLDJCQUEyQixDQUFTLGtCQUFtRCxFQUFFLFNBQWlCO1FBRzdHLE9BQU8sQ0FBQyxJQUE2QixFQUFFLE9BQTZDLEVBQWUsRUFBRSxDQUNyRyxDQUFDLE9BQXdCLEVBQTJCLEVBQUU7WUFDbEQsTUFBTSxhQUFhLEdBQUcsb0JBQW9CLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRWhFLE9BQU8sb0JBQW9CLENBQUMsOEJBQThCLENBQUMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDN0gsQ0FBQyxDQUFDO0lBQ1IsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLHdCQUF3QixDQUFtQixrQkFBbUUsRUFBRSxTQUFpQjtRQUlwSSxPQUFPLENBQUMsSUFBK0IsRUFBRSxJQUErQixFQUN0RSxPQUE2RCxFQUFlLEVBQUUsQ0FDOUUsQ0FBQyxPQUF3QixFQUEyQixFQUFFO1lBQ3BELE1BQU0sYUFBYSxHQUFHLG9CQUFvQixDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNoRSxNQUFNLGFBQWEsR0FBRyxvQkFBb0IsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFaEUsT0FBTyxvQkFBb0IsQ0FBQyw4QkFBOEIsQ0FBQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFDeEcsYUFBYSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ2xDLENBQUMsQ0FBQztJQUNSLENBQUM7SUFFTyxNQUFNLENBQUMsY0FBYyxDQUFJLEdBQWtCO1FBQ2pELElBQUksR0FBRyxZQUFZLFFBQVEsRUFBRTtZQUMzQixHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUM7U0FDYjtRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVPLE1BQU0sQ0FBQyw4QkFBOEIsQ0FBQyxPQUF3QjtJQUNwRSx3REFBd0Q7SUFDeEQsa0JBQW1ELEVBQUUsU0FBaUI7SUFDdEUsd0RBQXdEO0lBQ3hELE9BQStDLEVBQUUsR0FBRyxJQUFXO1FBRTdELE1BQU0sZ0JBQWdCLEdBQUcsb0JBQW9CLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDO1FBQzdGLG9CQUFvQixDQUFDLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFFakcsT0FBTyxnQkFBZ0IsQ0FBQztJQUM1QixDQUFDO0lBRUQsd0RBQXdEO0lBQ2hELE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBd0IsRUFBRSxrQkFBbUQsRUFBRSxHQUFHLElBQVc7UUFHakgsTUFBTSxrQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO1FBQ3ZELE9BQU8sa0JBQWtCLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVPLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxPQUF3QixFQUFFLFNBQWlCO0lBQzVFLHdEQUF3RDtJQUN4RCxnQkFBeUMsRUFBRSxPQUErQyxFQUFFLEdBQUcsSUFBVztRQUMxRyxJQUFJLE9BQU8sRUFBRTtZQUNYLElBQUksZ0JBQWdCLElBQUksZ0JBQWdCLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQ25ELElBQUksT0FBTyxPQUFPLEtBQUssVUFBVSxFQUFFO29CQUNqQyxPQUFPLEdBQUcsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7aUJBQzVCO2dCQUVELGlGQUFpRjtnQkFDakYsNEZBQTRGO2dCQUM1RixJQUFJLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUU7b0JBQy9ELGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztpQkFDbEM7Z0JBRUQsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsT0FBTyxDQUFDO2FBQ2xEO1NBQ0Y7SUFDSCxDQUFDO0lBRU8sTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFRO1FBQzlCLE9BQU8sR0FBRyxLQUFLLElBQUksSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZhbGlkYXRvckZuLCBWYWxpZGF0aW9uRXJyb3JzLCBBYnN0cmFjdENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcblxyXG4vKipcclxuICogQGR5bmFtaWNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBWYWxpZGF0b3JEZWNsYXJhdGlvbiB7XHJcbiAgLyoqXHJcbiAgICogV3JhcHMgeW91ciBvd24gdmFsaWRhdG9yIGZ1bmN0aW9ucyBmb3IgdXNlIHdpdGggdGhlIGFuZ3VsYXItcmVhY3RpdmUtdmFsaWRhdGlvbiBsaWJyYXJ5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHZhbGlkYXRvckZuIEEgZnVuY3Rpb24geW91IHdhbnQgdG8gd3JhcCB3aGljaCBjYW4gdmFsaWRhdGUgYSBjb250cm9sLlxyXG4gICAqIEBwYXJhbSByZXN1bHRLZXkgVGhlIGVycm9yIGtleSB1c2VkIGZvciBpbmRpY2F0aW5nIGFuIGVycm9yIHJlc3VsdCBhcyByZXR1cm5lZCBmcm9tIHRoZSBWYWxpZGF0b3JGbi5cclxuICAgKi9cclxuICBzdGF0aWMgd3JhcE5vQXJndW1lbnRWYWxpZGF0b3IodmFsaWRhdG9yRm46IFZhbGlkYXRvckZuLCByZXN1bHRLZXk6IHN0cmluZyk6XHJcbiAgICAobWVzc2FnZT86IHN0cmluZyB8ICgoKSA9PiBzdHJpbmcpKSA9PiBWYWxpZGF0b3JGbiB7XHJcbiAgICAgIHJldHVybiAobWVzc2FnZT86IHN0cmluZyB8ICgoKSA9PiBzdHJpbmcpKTogVmFsaWRhdG9yRm4gPT4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgICAgIFZhbGlkYXRvckRlY2xhcmF0aW9uLnZhbGlkYXRlQW5kU2V0TWVzc2FnZUlmSW52YWxpZChjb250cm9sLCAoKSA9PiB2YWxpZGF0b3JGbiwgcmVzdWx0S2V5LCBtZXNzYWdlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdyYXBzIHlvdXIgb3duIHZhbGlkYXRvciBmdW5jdGlvbnMgZm9yIHVzZSB3aXRoIHRoZSBhbmd1bGFyLXJlYWN0aXZlLXZhbGlkYXRpb24gbGlicmFyeS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YWxpZGF0b3JGYWN0b3J5Rm4gQSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzIGEgc2luZ2xlIGFyZ3VtZW50IGFuZCByZXR1cm5zIGEgVmFsaWRhdG9yRm4uXHJcbiAgICogQHBhcmFtIHJlc3VsdEtleSBUaGUgZXJyb3Iga2V5IHVzZWQgZm9yIGluZGljYXRpbmcgYW4gZXJyb3IgcmVzdWx0IGFzIHJldHVybmVkIGZyb20gdGhlIFZhbGlkYXRvckZuLlxyXG4gICAqL1xyXG4gIHN0YXRpYyB3cmFwU2luZ2xlQXJndW1lbnRWYWxpZGF0b3I8VElucHV0Pih2YWxpZGF0b3JGYWN0b3J5Rm46ICgoYXJnMTogVElucHV0KSA9PiBWYWxpZGF0b3JGbiksIHJlc3VsdEtleTogc3RyaW5nKTpcclxuICAgIChhcmcxOiBUSW5wdXQgfCAoKCkgPT4gVElucHV0KSwgbWVzc2FnZT86IHN0cmluZyB8ICgoYXJnMTogVElucHV0KSA9PiBzdHJpbmcpKSA9PiBWYWxpZGF0b3JGbiB7XHJcblxyXG4gICAgICByZXR1cm4gKGFyZzE6IFRJbnB1dCB8ICgoKSA9PiBUSW5wdXQpLCBtZXNzYWdlPzogc3RyaW5nIHwgKChhcmcxOiBUSW5wdXQpID0+IHN0cmluZykpOiBWYWxpZGF0b3JGbiA9PlxyXG4gICAgICAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xyXG4gICAgICAgICAgY29uc3QgdW53cmFwcGVkQXJnMSA9IFZhbGlkYXRvckRlY2xhcmF0aW9uLnVud3JhcEFyZ3VtZW50KGFyZzEpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBWYWxpZGF0b3JEZWNsYXJhdGlvbi52YWxpZGF0ZUFuZFNldE1lc3NhZ2VJZkludmFsaWQoY29udHJvbCwgdmFsaWRhdG9yRmFjdG9yeUZuLCByZXN1bHRLZXksIG1lc3NhZ2UsIHVud3JhcHBlZEFyZzEpO1xyXG4gICAgICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXcmFwcyB5b3VyIG93biB2YWxpZGF0b3IgZnVuY3Rpb25zIGZvciB1c2Ugd2l0aCB0aGUgYW5ndWxhci1yZWFjdGl2ZS12YWxpZGF0aW9uIGxpYnJhcnkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdmFsaWRhdG9yRmFjdG9yeUZuIEEgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyB0d28gYXJndW1lbnRzIGFuZCByZXR1cm5zIGEgVmFsaWRhdG9yRm4uXHJcbiAgICogQHBhcmFtIHJlc3VsdEtleSBUaGUgZXJyb3Iga2V5IHVzZWQgZm9yIGluZGljYXRpbmcgYW4gZXJyb3IgcmVzdWx0IGFzIHJldHVybmVkIGZyb20gdGhlIFZhbGlkYXRvckZuLlxyXG4gICAqL1xyXG4gIHN0YXRpYyB3cmFwVHdvQXJndW1lbnRWYWxpZGF0b3I8VElucHV0MSwgVElucHV0Mj4odmFsaWRhdG9yRmFjdG9yeUZuOiAoKGFyZzE6IFRJbnB1dDEsIGFyZzI6IFRJbnB1dDIpID0+IFZhbGlkYXRvckZuKSwgcmVzdWx0S2V5OiBzdHJpbmcpOlxyXG4gICAgKGFyZzE6IFRJbnB1dDEgfCAoKCkgPT4gVElucHV0MSksIGFyZzI6IFRJbnB1dDIgfCAoKCkgPT4gVElucHV0MiksIG1lc3NhZ2U/OiBzdHJpbmcgfCAoKGFyZzE6IFRJbnB1dDEsIGFyZzI6IFRJbnB1dDIpID0+IHN0cmluZykpID0+XHJcbiAgICBWYWxpZGF0b3JGbiB7XHJcblxyXG4gICAgICByZXR1cm4gKGFyZzE6IFRJbnB1dDEgfCAoKCkgPT4gVElucHV0MSksIGFyZzI6IFRJbnB1dDIgfCAoKCkgPT4gVElucHV0MiksXHJcbiAgICAgICAgbWVzc2FnZT86IHN0cmluZyB8ICgoYXJnMTogVElucHV0MSwgYXJnMjogVElucHV0MikgPT4gc3RyaW5nKSk6IFZhbGlkYXRvckZuID0+XHJcbiAgICAgICAgKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcclxuICAgICAgICAgIGNvbnN0IHVud3JhcHBlZEFyZzEgPSBWYWxpZGF0b3JEZWNsYXJhdGlvbi51bndyYXBBcmd1bWVudChhcmcxKTtcclxuICAgICAgICAgIGNvbnN0IHVud3JhcHBlZEFyZzIgPSBWYWxpZGF0b3JEZWNsYXJhdGlvbi51bndyYXBBcmd1bWVudChhcmcyKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gVmFsaWRhdG9yRGVjbGFyYXRpb24udmFsaWRhdGVBbmRTZXRNZXNzYWdlSWZJbnZhbGlkKGNvbnRyb2wsIHZhbGlkYXRvckZhY3RvcnlGbiwgcmVzdWx0S2V5LCBtZXNzYWdlLFxyXG4gICAgICAgICAgICB1bndyYXBwZWRBcmcxLCB1bndyYXBwZWRBcmcyKTtcclxuICAgICAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgdW53cmFwQXJndW1lbnQ8VD4oYXJnOiBUIHwgKCgpID0+IFQpKTogVCB7XHJcbiAgICBpZiAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgYXJnID0gYXJnKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFyZztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIHZhbGlkYXRlQW5kU2V0TWVzc2FnZUlmSW52YWxpZChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wsXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xyXG4gICAgdmFsaWRhdG9yRmFjdG9yeUZuOiAoLi4uYXJnczogYW55W10pID0+IFZhbGlkYXRvckZuLCByZXN1bHRLZXk6IHN0cmluZyxcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XHJcbiAgICBtZXNzYWdlPzogc3RyaW5nIHwgKCguLi5hcmdzOiBhbnlbXSkgPT4gc3RyaW5nKSwgLi4uYXJnczogYW55W10pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCB7XHJcblxyXG4gICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gVmFsaWRhdG9yRGVjbGFyYXRpb24udmFsaWRhdGUoY29udHJvbCwgdmFsaWRhdG9yRmFjdG9yeUZuLCAuLi5hcmdzKTtcclxuICAgICAgVmFsaWRhdG9yRGVjbGFyYXRpb24uc2V0TWVzc2FnZUlmSW52YWxpZChjb250cm9sLCByZXN1bHRLZXksIHZhbGlkYXRpb25SZXN1bHQsIG1lc3NhZ2UsIC4uLmFyZ3MpO1xyXG5cclxuICAgICAgcmV0dXJuIHZhbGlkYXRpb25SZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xyXG4gIHByaXZhdGUgc3RhdGljIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCwgdmFsaWRhdG9yRmFjdG9yeUZuOiAoLi4uYXJnczogYW55W10pID0+IFZhbGlkYXRvckZuLCAuLi5hcmdzOiBhbnlbXSk6XHJcbiAgICBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCB7XHJcblxyXG4gICAgICBjb25zdCB3cmFwcGVkVmFsaWRhdG9yRm4gPSB2YWxpZGF0b3JGYWN0b3J5Rm4oLi4uYXJncyk7XHJcbiAgICAgIHJldHVybiB3cmFwcGVkVmFsaWRhdG9yRm4oY29udHJvbCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0YXRpYyBzZXRNZXNzYWdlSWZJbnZhbGlkKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCwgcmVzdWx0S2V5OiBzdHJpbmcsXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xyXG4gICAgdmFsaWRhdGlvblJlc3VsdDogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwsIG1lc3NhZ2U/OiBzdHJpbmcgfCAoKC4uLmFyZ3M6IGFueVtdKSA9PiBzdHJpbmcpLCAuLi5hcmdzOiBhbnlbXSkge1xyXG4gICAgaWYgKG1lc3NhZ2UpIHtcclxuICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQgJiYgdmFsaWRhdGlvblJlc3VsdFtyZXN1bHRLZXldKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZSguLi5hcmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vdCBhbGwgdmFsaWRhdG9ycyBzZXQgYW4gb2JqZWN0LiBPZnRlbiB0aGV5J2xsIHNpbXBseSBzZXQgYSBwcm9wZXJ0eSB0byB0cnVlLlxyXG4gICAgICAgIC8vIEhlcmUsIHdlIHJlcGxhY2UgYW55IG5vbi1vYmplY3QgKG9yIGFycmF5KSB0byBiZSBhbiBvYmplY3Qgb24gd2hpY2ggd2UgY2FuIHNldCBhIG1lc3NhZ2UuXHJcbiAgICAgICAgaWYgKCFWYWxpZGF0b3JEZWNsYXJhdGlvbi5pc09iamVjdCh2YWxpZGF0aW9uUmVzdWx0W3Jlc3VsdEtleV0pKSB7XHJcbiAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0W3Jlc3VsdEtleV0gPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhbGlkYXRpb25SZXN1bHRbcmVzdWx0S2V5XVsnbWVzc2FnZSddID0gbWVzc2FnZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgaXNPYmplY3QoYXJnOiBhbnkpIHtcclxuICAgIHJldHVybiBhcmcgIT09IG51bGwgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJnKTtcclxuICB9XHJcbn1cclxuIl19